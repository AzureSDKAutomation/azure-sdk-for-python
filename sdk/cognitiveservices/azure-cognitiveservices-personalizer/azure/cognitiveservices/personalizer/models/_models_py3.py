# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.serialization import Model
from msrest.exceptions import HttpOperationError


class ContainerStatus(Model):
    """ContainerStatus.

    :param service:
    :type service: str
    :param api_status:
    :type api_status: str
    :param api_status_message:
    :type api_status_message: str
    """

    _attribute_map = {
        'service': {'key': 'service', 'type': 'str'},
        'api_status': {'key': 'apiStatus', 'type': 'str'},
        'api_status_message': {'key': 'apiStatusMessage', 'type': 'str'},
    }

    def __init__(self, *, service: str=None, api_status: str=None, api_status_message: str=None, **kwargs) -> None:
        super(ContainerStatus, self).__init__(**kwargs)
        self.service = service
        self.api_status = api_status
        self.api_status_message = api_status_message


class DateRange(Model):
    """DateRange.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar from_property:
    :vartype from_property: datetime
    :ivar to:
    :vartype to: datetime
    """

    _validation = {
        'from_property': {'readonly': True},
        'to': {'readonly': True},
    }

    _attribute_map = {
        'from_property': {'key': 'from', 'type': 'iso-8601'},
        'to': {'key': 'to', 'type': 'iso-8601'},
    }

    def __init__(self, **kwargs) -> None:
        super(DateRange, self).__init__(**kwargs)
        self.from_property = None
        self.to = None


class ErrorResponse(Model):
    """Used to return an error to the client.

    All required parameters must be populated in order to send to Azure.

    :param error: Required. The error object.
    :type error:
     ~azure.cognitiveservices.personalizer.models.PersonalizerError
    """

    _validation = {
        'error': {'required': True},
    }

    _attribute_map = {
        'error': {'key': 'error', 'type': 'PersonalizerError'},
    }

    def __init__(self, *, error, **kwargs) -> None:
        super(ErrorResponse, self).__init__(**kwargs)
        self.error = error


class ErrorResponseException(HttpOperationError):
    """Server responsed with exception of type: 'ErrorResponse'.

    :param deserialize: A deserializer
    :param response: Server response to be deserialized.
    """

    def __init__(self, deserialize, response, *args):

        super(ErrorResponseException, self).__init__(deserialize, response, 'ErrorResponse', *args)


class Evaluation(Model):
    """Evaluation.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id:
    :vartype id: str
    :ivar name:
    :vartype name: str
    :ivar start_time:
    :vartype start_time: datetime
    :ivar end_time:
    :vartype end_time: datetime
    :ivar job_id:
    :vartype job_id: str
    :ivar status: Possible values include: 'completed', 'pending', 'failed',
     'notSubmitted', 'timeout'
    :vartype status: str or
     ~azure.cognitiveservices.personalizer.models.EvaluationJobStatus
    :param policy_results:
    :type policy_results:
     list[~azure.cognitiveservices.personalizer.models.PolicyResult]
    :param feature_importance:
    :type feature_importance: list[list[str]]
    """

    _validation = {
        'id': {'readonly': True, 'max_length': 256},
        'name': {'readonly': True, 'max_length': 256},
        'start_time': {'readonly': True},
        'end_time': {'readonly': True},
        'job_id': {'readonly': True},
        'status': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'start_time': {'key': 'startTime', 'type': 'iso-8601'},
        'end_time': {'key': 'endTime', 'type': 'iso-8601'},
        'job_id': {'key': 'jobId', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'policy_results': {'key': 'policyResults', 'type': '[PolicyResult]'},
        'feature_importance': {'key': 'featureImportance', 'type': '[[str]]'},
    }

    def __init__(self, *, policy_results=None, feature_importance=None, **kwargs) -> None:
        super(Evaluation, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.start_time = None
        self.end_time = None
        self.job_id = None
        self.status = None
        self.policy_results = policy_results
        self.feature_importance = feature_importance


class EvaluationContract(Model):
    """A counterfactual evaluation.

    All required parameters must be populated in order to send to Azure.

    :param enable_offline_experimentation: True if the evaluation should
     explore for a more optimal learning settings.
    :type enable_offline_experimentation: bool
    :param name: Required. The name of the evaluation.
    :type name: str
    :param start_time: Required. The start time of the evaluation.
    :type start_time: datetime
    :param end_time: Required. The end time of the evaluation.
    :type end_time: datetime
    :param policies: Required. Additional learning settings to evaluate.
    :type policies:
     list[~azure.cognitiveservices.personalizer.models.PolicyContract]
    """

    _validation = {
        'name': {'required': True, 'max_length': 256},
        'start_time': {'required': True},
        'end_time': {'required': True},
        'policies': {'required': True},
    }

    _attribute_map = {
        'enable_offline_experimentation': {'key': 'enableOfflineExperimentation', 'type': 'bool'},
        'name': {'key': 'name', 'type': 'str'},
        'start_time': {'key': 'startTime', 'type': 'iso-8601'},
        'end_time': {'key': 'endTime', 'type': 'iso-8601'},
        'policies': {'key': 'policies', 'type': '[PolicyContract]'},
    }

    def __init__(self, *, name: str, start_time, end_time, policies, enable_offline_experimentation: bool=None, **kwargs) -> None:
        super(EvaluationContract, self).__init__(**kwargs)
        self.enable_offline_experimentation = enable_offline_experimentation
        self.name = name
        self.start_time = start_time
        self.end_time = end_time
        self.policies = policies


class InternalError(Model):
    """An object containing more specific information than the parent object about
    the error.

    :param code: Detailed error code.
    :type code: str
    :param innererror: The error object.
    :type innererror:
     ~azure.cognitiveservices.personalizer.models.InternalError
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'innererror': {'key': 'innererror', 'type': 'InternalError'},
    }

    def __init__(self, *, code: str=None, innererror=None, **kwargs) -> None:
        super(InternalError, self).__init__(**kwargs)
        self.code = code
        self.innererror = innererror


class LogsProperties(Model):
    """LogsProperties.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar date_range:
    :vartype date_range:
     ~azure.cognitiveservices.personalizer.models.LogsPropertiesDateRange
    """

    _validation = {
        'date_range': {'readonly': True},
    }

    _attribute_map = {
        'date_range': {'key': 'dateRange', 'type': 'LogsPropertiesDateRange'},
    }

    def __init__(self, **kwargs) -> None:
        super(LogsProperties, self).__init__(**kwargs)
        self.date_range = None


class LogsPropertiesDateRange(DateRange):
    """LogsPropertiesDateRange.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar from_property:
    :vartype from_property: datetime
    :ivar to:
    :vartype to: datetime
    """

    _validation = {
        'from_property': {'readonly': True},
        'to': {'readonly': True},
    }

    _attribute_map = {
        'from_property': {'key': 'from', 'type': 'iso-8601'},
        'to': {'key': 'to', 'type': 'iso-8601'},
    }

    def __init__(self, **kwargs) -> None:
        super(LogsPropertiesDateRange, self).__init__(**kwargs)


class Metric(Model):
    """Metric.

    All required parameters must be populated in order to send to Azure.

    :param learning_mode: Required. Possible values include: 'Online',
     'Apprentice', 'LoggingOnly'
    :type learning_mode: str or
     ~azure.cognitiveservices.personalizer.models.LearningMode
    :param start_date: Required.
    :type start_date: datetime
    :param end_date: Required.
    :type end_date: datetime
    :param number_of_events: Required.
    :type number_of_events: long
    :param sum_of_rewards: Required.
    :type sum_of_rewards: float
    :param number_of_matched_events: Required.
    :type number_of_matched_events: long
    :param sum_of_imitated_rewards: Required.
    :type sum_of_imitated_rewards: float
    :param cumulative_number_of_events: Required.
    :type cumulative_number_of_events: long
    :param cumulative_sum_of_rewards: Required.
    :type cumulative_sum_of_rewards: float
    :param cumulative_number_of_matched_events: Required.
    :type cumulative_number_of_matched_events: long
    :param cumulative_sum_of_imitated_rewards: Required.
    :type cumulative_sum_of_imitated_rewards: float
    """

    _validation = {
        'learning_mode': {'required': True},
        'start_date': {'required': True},
        'end_date': {'required': True},
        'number_of_events': {'required': True},
        'sum_of_rewards': {'required': True},
        'number_of_matched_events': {'required': True},
        'sum_of_imitated_rewards': {'required': True},
        'cumulative_number_of_events': {'required': True},
        'cumulative_sum_of_rewards': {'required': True},
        'cumulative_number_of_matched_events': {'required': True},
        'cumulative_sum_of_imitated_rewards': {'required': True},
    }

    _attribute_map = {
        'learning_mode': {'key': 'learningMode', 'type': 'str'},
        'start_date': {'key': 'startDate', 'type': 'iso-8601'},
        'end_date': {'key': 'endDate', 'type': 'iso-8601'},
        'number_of_events': {'key': 'numberOfEvents', 'type': 'long'},
        'sum_of_rewards': {'key': 'sumOfRewards', 'type': 'float'},
        'number_of_matched_events': {'key': 'numberOfMatchedEvents', 'type': 'long'},
        'sum_of_imitated_rewards': {'key': 'sumOfImitatedRewards', 'type': 'float'},
        'cumulative_number_of_events': {'key': 'cumulativeNumberOfEvents', 'type': 'long'},
        'cumulative_sum_of_rewards': {'key': 'cumulativeSumOfRewards', 'type': 'float'},
        'cumulative_number_of_matched_events': {'key': 'cumulativeNumberOfMatchedEvents', 'type': 'long'},
        'cumulative_sum_of_imitated_rewards': {'key': 'cumulativeSumOfImitatedRewards', 'type': 'float'},
    }

    def __init__(self, *, learning_mode, start_date, end_date, number_of_events: int, sum_of_rewards: float, number_of_matched_events: int, sum_of_imitated_rewards: float, cumulative_number_of_events: int, cumulative_sum_of_rewards: float, cumulative_number_of_matched_events: int, cumulative_sum_of_imitated_rewards: float, **kwargs) -> None:
        super(Metric, self).__init__(**kwargs)
        self.learning_mode = learning_mode
        self.start_date = start_date
        self.end_date = end_date
        self.number_of_events = number_of_events
        self.sum_of_rewards = sum_of_rewards
        self.number_of_matched_events = number_of_matched_events
        self.sum_of_imitated_rewards = sum_of_imitated_rewards
        self.cumulative_number_of_events = cumulative_number_of_events
        self.cumulative_sum_of_rewards = cumulative_sum_of_rewards
        self.cumulative_number_of_matched_events = cumulative_number_of_matched_events
        self.cumulative_sum_of_imitated_rewards = cumulative_sum_of_imitated_rewards


class ModelMetadata(Model):
    """ModelMetadata.

    All required parameters must be populated in order to send to Azure.

    :param model_id: Required.
    :type model_id: str
    :param user_description: Required.
    :type user_description: str
    :param creation_date: Required.
    :type creation_date: datetime
    :param last_config_edit_date: Required.
    :type last_config_edit_date: datetime
    :param first_event_id: Required.
    :type first_event_id: str
    :param last_event_id: Required.
    :type last_event_id: str
    :param saved_in_history: Required.
    :type saved_in_history: bool
    :param number_of_events_learned_since_last_export: Required.
    :type number_of_events_learned_since_last_export: int
    """

    _validation = {
        'model_id': {'required': True},
        'user_description': {'required': True},
        'creation_date': {'required': True},
        'last_config_edit_date': {'required': True},
        'first_event_id': {'required': True},
        'last_event_id': {'required': True},
        'saved_in_history': {'required': True},
        'number_of_events_learned_since_last_export': {'required': True},
    }

    _attribute_map = {
        'model_id': {'key': 'modelId', 'type': 'str'},
        'user_description': {'key': 'userDescription', 'type': 'str'},
        'creation_date': {'key': 'creationDate', 'type': 'iso-8601'},
        'last_config_edit_date': {'key': 'lastConfigEditDate', 'type': 'iso-8601'},
        'first_event_id': {'key': 'firstEventId', 'type': 'str'},
        'last_event_id': {'key': 'lastEventId', 'type': 'str'},
        'saved_in_history': {'key': 'savedInHistory', 'type': 'bool'},
        'number_of_events_learned_since_last_export': {'key': 'numberOfEventsLearnedSinceLastExport', 'type': 'int'},
    }

    def __init__(self, *, model_id: str, user_description: str, creation_date, last_config_edit_date, first_event_id: str, last_event_id: str, saved_in_history: bool, number_of_events_learned_since_last_export: int, **kwargs) -> None:
        super(ModelMetadata, self).__init__(**kwargs)
        self.model_id = model_id
        self.user_description = user_description
        self.creation_date = creation_date
        self.last_config_edit_date = last_config_edit_date
        self.first_event_id = first_event_id
        self.last_event_id = last_event_id
        self.saved_in_history = saved_in_history
        self.number_of_events_learned_since_last_export = number_of_events_learned_since_last_export


class ModelProperties(Model):
    """ModelProperties.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar creation_time:
    :vartype creation_time: datetime
    :ivar last_modified_time:
    :vartype last_modified_time: datetime
    """

    _validation = {
        'creation_time': {'readonly': True},
        'last_modified_time': {'readonly': True},
    }

    _attribute_map = {
        'creation_time': {'key': 'creationTime', 'type': 'iso-8601'},
        'last_modified_time': {'key': 'lastModifiedTime', 'type': 'iso-8601'},
    }

    def __init__(self, **kwargs) -> None:
        super(ModelProperties, self).__init__(**kwargs)
        self.creation_time = None
        self.last_modified_time = None


class PersonalizerError(Model):
    """The error object.

    All required parameters must be populated in order to send to Azure.

    :param code: Required. High level error code. Possible values include:
     'BadRequest', 'InvalidServiceConfiguration',
     'InvalidLearningModeServiceConfiguration', 'InvalidPolicyConfiguration',
     'InvalidPolicyContract', 'InvalidEvaluationContract',
     'DuplicateCustomPolicyNames', 'NoLogsExistInDateRange',
     'LogsSizeExceedAllowedLimit', 'InvalidRewardRequest',
     'InvalidEventIdToActivate', 'InvalidRankRequest',
     'InvalidExportLogsRequest', 'InvalidContainer', 'InvalidModelMetadata',
     'ApprenticeModeNeverTurnedOn', 'MissingAppId',
     'AggregationIntervalTooShort', 'AggregationIntervalInvalid',
     'InvalidStartDateEndDate', 'AggregationEventCountTooSmall',
     'AggregationEventCountInvalid', 'ModelFileAccessDenied',
     'ResourceNotFound', 'FrontEndNotFound', 'EvaluationNotFound',
     'LogsPropertiesNotFound', 'ModelRankingError', 'InternalServerError',
     'RankNullResponse', 'UpdateConfigurationFailed', 'ModelResetFailed',
     'ModelPublishFailed', 'ModelMetadataUpdateFailed', 'KeyVaultNotFound',
     'None'
    :type code: str or
     ~azure.cognitiveservices.personalizer.models.PersonalizerErrorCode
    :param message: Required. A message explaining the error reported by the
     service.
    :type message: str
    :param target: Error source element.
    :type target: str
    :param details: An array of details about specific errors that led to this
     reported error.
    :type details:
     list[~azure.cognitiveservices.personalizer.models.PersonalizerError]
    :param inner_error: Finer error details.
    :type inner_error:
     ~azure.cognitiveservices.personalizer.models.InternalError
    """

    _validation = {
        'code': {'required': True},
        'message': {'required': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'details': {'key': 'details', 'type': '[PersonalizerError]'},
        'inner_error': {'key': 'innerError', 'type': 'InternalError'},
    }

    def __init__(self, *, code, message: str, target: str=None, details=None, inner_error=None, **kwargs) -> None:
        super(PersonalizerError, self).__init__(**kwargs)
        self.code = code
        self.message = message
        self.target = target
        self.details = details
        self.inner_error = inner_error


class PolicyContract(Model):
    """Learning settings specifying how to train the model.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. Name of the learning settings.
    :type name: str
    :param arguments: Required. Arguments of the learning settings.
    :type arguments: str
    """

    _validation = {
        'name': {'required': True, 'max_length': 256},
        'arguments': {'required': True, 'max_length': 1024},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'arguments': {'key': 'arguments', 'type': 'str'},
    }

    def __init__(self, *, name: str, arguments: str, **kwargs) -> None:
        super(PolicyContract, self).__init__(**kwargs)
        self.name = name
        self.arguments = arguments


class PolicyResult(Model):
    """PolicyResult.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar name:
    :vartype name: str
    :ivar arguments:
    :vartype arguments: str
    :ivar summary:
    :vartype summary:
     list[~azure.cognitiveservices.personalizer.models.PolicyResultSummary]
    :ivar total_summary:
    :vartype total_summary:
     ~azure.cognitiveservices.personalizer.models.PolicyResultTotalSummary
    """

    _validation = {
        'name': {'readonly': True},
        'arguments': {'readonly': True},
        'summary': {'readonly': True},
        'total_summary': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'arguments': {'key': 'arguments', 'type': 'str'},
        'summary': {'key': 'summary', 'type': '[PolicyResultSummary]'},
        'total_summary': {'key': 'totalSummary', 'type': 'PolicyResultTotalSummary'},
    }

    def __init__(self, **kwargs) -> None:
        super(PolicyResult, self).__init__(**kwargs)
        self.name = None
        self.arguments = None
        self.summary = None
        self.total_summary = None


class PolicyResultSummary(Model):
    """PolicyResultSummary.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar time_stamp:
    :vartype time_stamp: datetime
    :ivar ips_estimator_numerator:
    :vartype ips_estimator_numerator: float
    :ivar ips_estimator_denominator:
    :vartype ips_estimator_denominator: float
    :ivar snips_estimator_denominator:
    :vartype snips_estimator_denominator: float
    :ivar aggregate_time_window:
    :vartype aggregate_time_window: timedelta
    :param non_zero_probability:
    :type non_zero_probability: float
    :ivar confidence_interval:
    :vartype confidence_interval: float
    :ivar sum_of_squares:
    :vartype sum_of_squares: float
    """

    _validation = {
        'time_stamp': {'readonly': True},
        'ips_estimator_numerator': {'readonly': True},
        'ips_estimator_denominator': {'readonly': True},
        'snips_estimator_denominator': {'readonly': True},
        'aggregate_time_window': {'readonly': True},
        'confidence_interval': {'readonly': True},
        'sum_of_squares': {'readonly': True},
    }

    _attribute_map = {
        'time_stamp': {'key': 'timeStamp', 'type': 'iso-8601'},
        'ips_estimator_numerator': {'key': 'ipsEstimatorNumerator', 'type': 'float'},
        'ips_estimator_denominator': {'key': 'ipsEstimatorDenominator', 'type': 'float'},
        'snips_estimator_denominator': {'key': 'snipsEstimatorDenominator', 'type': 'float'},
        'aggregate_time_window': {'key': 'aggregateTimeWindow', 'type': 'duration'},
        'non_zero_probability': {'key': 'nonZeroProbability', 'type': 'float'},
        'confidence_interval': {'key': 'confidenceInterval', 'type': 'float'},
        'sum_of_squares': {'key': 'sumOfSquares', 'type': 'float'},
    }

    def __init__(self, *, non_zero_probability: float=None, **kwargs) -> None:
        super(PolicyResultSummary, self).__init__(**kwargs)
        self.time_stamp = None
        self.ips_estimator_numerator = None
        self.ips_estimator_denominator = None
        self.snips_estimator_denominator = None
        self.aggregate_time_window = None
        self.non_zero_probability = non_zero_probability
        self.confidence_interval = None
        self.sum_of_squares = None


class PolicyResultTotalSummary(PolicyResultSummary):
    """PolicyResultTotalSummary.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar time_stamp:
    :vartype time_stamp: datetime
    :ivar ips_estimator_numerator:
    :vartype ips_estimator_numerator: float
    :ivar ips_estimator_denominator:
    :vartype ips_estimator_denominator: float
    :ivar snips_estimator_denominator:
    :vartype snips_estimator_denominator: float
    :ivar aggregate_time_window:
    :vartype aggregate_time_window: timedelta
    :param non_zero_probability:
    :type non_zero_probability: float
    :ivar confidence_interval:
    :vartype confidence_interval: float
    :ivar sum_of_squares:
    :vartype sum_of_squares: float
    """

    _validation = {
        'time_stamp': {'readonly': True},
        'ips_estimator_numerator': {'readonly': True},
        'ips_estimator_denominator': {'readonly': True},
        'snips_estimator_denominator': {'readonly': True},
        'aggregate_time_window': {'readonly': True},
        'confidence_interval': {'readonly': True},
        'sum_of_squares': {'readonly': True},
    }

    _attribute_map = {
        'time_stamp': {'key': 'timeStamp', 'type': 'iso-8601'},
        'ips_estimator_numerator': {'key': 'ipsEstimatorNumerator', 'type': 'float'},
        'ips_estimator_denominator': {'key': 'ipsEstimatorDenominator', 'type': 'float'},
        'snips_estimator_denominator': {'key': 'snipsEstimatorDenominator', 'type': 'float'},
        'aggregate_time_window': {'key': 'aggregateTimeWindow', 'type': 'duration'},
        'non_zero_probability': {'key': 'nonZeroProbability', 'type': 'float'},
        'confidence_interval': {'key': 'confidenceInterval', 'type': 'float'},
        'sum_of_squares': {'key': 'sumOfSquares', 'type': 'float'},
    }

    def __init__(self, *, non_zero_probability: float=None, **kwargs) -> None:
        super(PolicyResultTotalSummary, self).__init__(non_zero_probability=non_zero_probability, **kwargs)


class RankableAction(Model):
    """An action with it's associated features used for ranking.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. Id of the action.
    :type id: str
    :param features: Required. List of dictionaries containing features.
    :type features: list[object]
    """

    _validation = {
        'id': {'required': True, 'max_length': 256, 'min_length': 1},
        'features': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'features': {'key': 'features', 'type': '[object]'},
    }

    def __init__(self, *, id: str, features, **kwargs) -> None:
        super(RankableAction, self).__init__(**kwargs)
        self.id = id
        self.features = features


class RankedAction(Model):
    """A ranked action with its resulting probability.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Id of the action
    :vartype id: str
    :ivar probability: Probability of the action
    :vartype probability: float
    """

    _validation = {
        'id': {'readonly': True, 'max_length': 256},
        'probability': {'readonly': True, 'maximum': 1, 'minimum': 0},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'probability': {'key': 'probability', 'type': 'float'},
    }

    def __init__(self, **kwargs) -> None:
        super(RankedAction, self).__init__(**kwargs)
        self.id = None
        self.probability = None


class RankRequest(Model):
    """Request a set of actions to be ranked by the Personalizer service.

    All required parameters must be populated in order to send to Azure.

    :param context_features: Features of the context used for Personalizer as
     a
     dictionary of dictionaries. This depends on the application, and
     typically includes features about the current user, their
     device, profile information, aggregated data about time and date, etc.
     Features should not include personally identifiable information (PII),
     unique UserIDs, or precise timestamps.
    :type context_features: list[object]
    :param actions: Required. The set of actions the Personalizer service can
     pick from.
     The set should not contain more than 50 actions.
     The order of the actions does not affect the rank result but the order
     should match the sequence your application would have used to display
     them.
     The first item in the array will be used as Baseline item in Offline
     evaluations.
    :type actions:
     list[~azure.cognitiveservices.personalizer.models.RankableAction]
    :param excluded_actions: The set of action ids to exclude from ranking.
    :type excluded_actions: list[str]
    :param event_id: Optionally pass an eventId that uniquely identifies this
     Rank event.
     If null, the service generates a unique eventId. The eventId will be used
     for
     associating this request with its reward, as well as seeding the
     pseudo-random
     generator when making a Personalizer call.
    :type event_id: str
    :param defer_activation: Send false if it is certain the rewardActionId in
     rank results will be shown to the user, therefore
     Personalizer will expect a Reward call, otherwise it will assign the
     default
     Reward to the event. Send true if it is possible the user will not see the
     action specified in the rank results, because the page is rendering later,
     or the Rank results may be
     overridden by code further downstream. Default value: False .
    :type defer_activation: bool
    """

    _validation = {
        'actions': {'required': True},
        'event_id': {'max_length': 256},
    }

    _attribute_map = {
        'context_features': {'key': 'contextFeatures', 'type': '[object]'},
        'actions': {'key': 'actions', 'type': '[RankableAction]'},
        'excluded_actions': {'key': 'excludedActions', 'type': '[str]'},
        'event_id': {'key': 'eventId', 'type': 'str'},
        'defer_activation': {'key': 'deferActivation', 'type': 'bool'},
    }

    def __init__(self, *, actions, context_features=None, excluded_actions=None, event_id: str=None, defer_activation: bool=False, **kwargs) -> None:
        super(RankRequest, self).__init__(**kwargs)
        self.context_features = context_features
        self.actions = actions
        self.excluded_actions = excluded_actions
        self.event_id = event_id
        self.defer_activation = defer_activation


class RankResponse(Model):
    """Returns which action to use as rewardActionId, and additional information
    about each action as a result of a Rank request.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar ranking: The calculated ranking for the current request.
    :vartype ranking:
     list[~azure.cognitiveservices.personalizer.models.RankedAction]
    :ivar event_id: The eventId for the round trip from request to response.
    :vartype event_id: str
    :ivar reward_action_id: The action chosen by the Personalizer service.
     This is the action your application should display, and for which to
     report the reward. This might not be the
     first found in 'ranking' if an action in the request in first position was
     part of the excluded ids.
    :vartype reward_action_id: str
    """

    _validation = {
        'ranking': {'readonly': True},
        'event_id': {'readonly': True, 'max_length': 256},
        'reward_action_id': {'readonly': True, 'max_length': 256},
    }

    _attribute_map = {
        'ranking': {'key': 'ranking', 'type': '[RankedAction]'},
        'event_id': {'key': 'eventId', 'type': 'str'},
        'reward_action_id': {'key': 'rewardActionId', 'type': 'str'},
    }

    def __init__(self, **kwargs) -> None:
        super(RankResponse, self).__init__(**kwargs)
        self.ranking = None
        self.event_id = None
        self.reward_action_id = None


class RewardRequest(Model):
    """Reward given to a rank response.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. Reward to be assigned to an action. Value should
     be between -1 and 1 inclusive.
    :type value: float
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': 'float'},
    }

    def __init__(self, *, value: float, **kwargs) -> None:
        super(RewardRequest, self).__init__(**kwargs)
        self.value = value


class ServiceConfiguration(Model):
    """The configuration of the service.

    All required parameters must be populated in order to send to Azure.

    :param reward_wait_time: Required. The time span waited until a request is
     marked with the default reward.
     For example, PT5M (5 mins). For information about the time format,
     see http://en.wikipedia.org/wiki/ISO_8601#Durations
    :type reward_wait_time: timedelta
    :param default_reward: Required. The reward given if a reward is not
     received within the specified wait time.
    :type default_reward: float
    :param reward_aggregation: Required. The function used to process rewards,
     if multiple reward scores are received before rewardWaitTime is over.
    :type reward_aggregation: str
    :param exploration_percentage: Required. The percentage of rank responses
     that will use exploration.
    :type exploration_percentage: float
    :param model_export_frequency: Required. Personalizer will start using the
     most updated trained model for online ranks automatically every specified
     time period.
     For example, PT5M (5 mins). For information about the time format,
     see http://en.wikipedia.org/wiki/ISO_8601#Durations
    :type model_export_frequency: timedelta
    :param log_mirror_enabled: Flag indicates whether log mirroring is
     enabled.
    :type log_mirror_enabled: bool
    :param log_mirror_sas_uri: Azure storage account container SAS URI for log
     mirroring.
    :type log_mirror_sas_uri: str
    :param log_retention_days: Required. Number of days historical logs are to
     be maintained. -1 implies the logs will never be deleted.
    :type log_retention_days: int
    :param model_auto_publish: When auto-publish is enabled (= default), the
     trainer exports the model and override the "current" model.
     When auto-publish is disabled, the trainer exports models but does not
     override the "current" model (this is done by the user through API calls).
     Default value: True .
    :type model_auto_publish: bool
    :param staged_model_history_length: Old models are automatically cleaned
     except the last N models. Default value: 10 .
    :type staged_model_history_length: int
    :param last_configuration_edit_date: Last time model training
     configuration was updated
    :type last_configuration_edit_date: datetime
    :param learning_mode: Learning mode for Personalizer
     Microsoft.DecisionService.Common.LearningMode. Possible values include:
     'Online', 'Apprentice', 'LoggingOnly'
    :type learning_mode: str or
     ~azure.cognitiveservices.personalizer.models.LearningMode
    """

    _validation = {
        'reward_wait_time': {'required': True},
        'default_reward': {'required': True, 'maximum': 1, 'minimum': -1},
        'reward_aggregation': {'required': True, 'max_length': 256},
        'exploration_percentage': {'required': True, 'maximum': 1, 'minimum': 0},
        'model_export_frequency': {'required': True},
        'log_retention_days': {'required': True, 'maximum': 2147483647, 'minimum': -1},
    }

    _attribute_map = {
        'reward_wait_time': {'key': 'rewardWaitTime', 'type': 'duration'},
        'default_reward': {'key': 'defaultReward', 'type': 'float'},
        'reward_aggregation': {'key': 'rewardAggregation', 'type': 'str'},
        'exploration_percentage': {'key': 'explorationPercentage', 'type': 'float'},
        'model_export_frequency': {'key': 'modelExportFrequency', 'type': 'duration'},
        'log_mirror_enabled': {'key': 'logMirrorEnabled', 'type': 'bool'},
        'log_mirror_sas_uri': {'key': 'logMirrorSasUri', 'type': 'str'},
        'log_retention_days': {'key': 'logRetentionDays', 'type': 'int'},
        'model_auto_publish': {'key': 'modelAutoPublish', 'type': 'bool'},
        'staged_model_history_length': {'key': 'stagedModelHistoryLength', 'type': 'int'},
        'last_configuration_edit_date': {'key': 'lastConfigurationEditDate', 'type': 'iso-8601'},
        'learning_mode': {'key': 'learningMode', 'type': 'str'},
    }

    def __init__(self, *, reward_wait_time, default_reward: float, reward_aggregation: str, exploration_percentage: float, model_export_frequency, log_retention_days: int, log_mirror_enabled: bool=None, log_mirror_sas_uri: str=None, model_auto_publish: bool=True, staged_model_history_length: int=10, last_configuration_edit_date=None, learning_mode=None, **kwargs) -> None:
        super(ServiceConfiguration, self).__init__(**kwargs)
        self.reward_wait_time = reward_wait_time
        self.default_reward = default_reward
        self.reward_aggregation = reward_aggregation
        self.exploration_percentage = exploration_percentage
        self.model_export_frequency = model_export_frequency
        self.log_mirror_enabled = log_mirror_enabled
        self.log_mirror_sas_uri = log_mirror_sas_uri
        self.log_retention_days = log_retention_days
        self.model_auto_publish = model_auto_publish
        self.staged_model_history_length = staged_model_history_length
        self.last_configuration_edit_date = last_configuration_edit_date
        self.learning_mode = learning_mode
